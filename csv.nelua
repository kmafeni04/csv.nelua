require "io"

global csv = @record{}

local function parse(content: string, delim: facultative(string), header: boolean): sequence(hashmap(string, string))
  local tbl: sequence(hashmap(string, string))

  ## if delim.type.is_niltype then
    local actual_delim = ","
  ## else
    local actual_delim = delim
  ## end

  -- Unique set of characters to avoid accidental new line swaps
  local NEW_LINE_SWAP <const> = "\\__n"

  -- Unique set of characters to avoid accidental delim swaps
  local DELIM_SWAP = "__;"
  if DELIM_SWAP == actual_delim then
    DELIM_SWAP = "__,"
  end
  for string in content:gmatch('%b""') do
    local find_start, find_end = content:find(string)
    string = string:gsub("\n", NEW_LINE_SWAP)
    string = string:gsub("%" .. actual_delim, DELIM_SWAP)
    content = content:sub(1, find_start - 1) .. string .. content:sub(find_end + 1)
  end
  
  local headers: sequence(string)
  local line_no = 1
  for line in content:gmatch("[^\n]+") do
    local col_no = 1
    if header then
      if line_no == 1 then
        for col in line:gmatch(("[^%s]+"):format(actual_delim)) do
          col = col:gsub(NEW_LINE_SWAP, "\n")
          col = col:gsub(DELIM_SWAP, actual_delim)
          headers:push(col)
        end
      end
    end
    local row: hashmap(string, string)
    for col in line:gmatch(("[^%s]+"):format(actual_delim)) do
      col = col:gsub(NEW_LINE_SWAP, "\n")
      col = col:gsub(DELIM_SWAP, actual_delim)
      if header then
        if line_no ~= 1 then
          row[headers[col_no]] = col
        end
      else
        row["column " .. col_no] = col
      end
      col_no = col_no + 1
    end
    if header then
      if line_no ~= 1 then
        tbl:push(row)
      end
    else
      tbl:push(row)
    end
    line_no = line_no + 1
  end
  return tbl
end

function csv.parse_file(file: string, delim: facultative(string), header: boolean): sequence(hashmap(string, string))
  local file_prog = io.open(file)
  if not file_prog:isopen() then
    error(("Failed to open file: %s"):format(file))
  end
  local content = file_prog:read("a")
  return parse(content, delim, header)
end

function csv.parse_string(content: string, delim: facultative(string), header: boolean): sequence(hashmap(string, string))
  return parse(content, delim, header)
end

-- TODO: Handle empty fields better
function csv.encode(tbl: span(span(string)), delim: facultative(string)): string
  ## if delim.type.is_niltype then
    local actual_delim = ","
  ## else
    local actual_delim = delim
  ## end
  local sb: stringbuilder
  local row_length = #tbl[1]
    for _, row in ipairs(tbl) do 
      assert(row_length == #row, "Rows must contain the same amount of entries")
      for _, v in pairs(row) do
        sb:write(v .. actual_delim)
      end
      sb:rollback(1)
      sb:write("\n")
    end
  return sb:promote()
end
